
import argparse
from collections import defaultdict
import re

def get_options():
    description = "Splits clusters based on synteny."
    parser = argparse.ArgumentParser(description=description,
                                        prog='python orthosynteny.py')
    IO = parser.add_argument_group('Input/options.out')
    IO.add_argument('--infile',
                    required=True,
                    help='tsv file generated by orthofinder')
    IO.add_argument('--outfile',
                    required=False,
                    default="parsed_output.tsv",
                    help='Output file.')
    IO.add_argument('--window-size',
                    type=int,
                    default=4,
                    help='Size either side of a gene of interest to search. Default=4')
    IO.add_argument('--min-jacc',
                    type=float,
                    default=0.5,
                    help='Minimum Jaccard index of matches to keep cluster. Default=0.5')
    IO.add_argument('--debug',
                    action="store_true",
                    default=False,
                    help='Debug mode. Only run if comparing self-self.')
    return parser.parse_args()

# for debugging
search_COG1 = ""
search_COG2 = ""

def jaccard_similarity(set1, set2):
    intersection = len(set1.intersection(set2))
    union = (len(set1) + len(set2)) - intersection
    return float(intersection) / union

def main():
    options = get_options()
    infile = options.infile
    window_size = options.window_size
    min_jacc = options.min_jacc
    outfile = options.outfile
    debug = options.debug

    COG_dict = {}
    position_list = None
    species_names = None
    num_genes_list = []
    with open(infile, "r") as f:
        header = f.readline().rstrip().split("\t")
        position_list = [ {} for _ in range(len(header) - 1)]
        num_genes_list = [ 0 for _ in range(len(header) - 1)]

        species_names = header[1:]

        for line in f:
            split_line = line.rstrip().split("\t")
            COG_name = split_line[0]
            species_entries = split_line[1:]
    
            for index, entry in enumerate(species_entries):
                species_genes = entry.split(", ")

                if species_genes == ['']:
                    continue

                species_gene_position = []
                for x in species_genes:
                    hit = re.search(r"^.+_0*(\d+)", x)
                    if hit:
                        species_gene_position.append(int(hit.group(1)))
                
                max_gene_pos = max(species_gene_position)
                prev_max_gene_pos = num_genes_list[index]
                num_genes_list[index] = max(max_gene_pos, prev_max_gene_pos)

                #species_gene_position = [int(x.split("_")[-1].lstrip("0")) for x in species_genes]
                #print(species_gene_position)

                if COG_name not in COG_dict:
                    COG_dict[COG_name] = [ set() for _ in range(len(header) - 1)]

                COG_dict[COG_name][index].update(species_gene_position)

                for pos in species_gene_position:
                    position_list[index][pos] = COG_name

    #print(f"COG_dict:\n{COG_dict}")
    #print(f"position_list:\n{position_list}")

    genes_to_ignore = set()
    COGs_to_cluster = {}
    num_matches = 0
    with open(outfile, "w") as o:
        o.write("Orthogroup\t" + "\t".join(species_names) + "\n")
        for COG_name, species_list in COG_dict.items():
            synteny_lists = [ {} for _ in range(len(header) - 1)]
            for species_idx, gene_set in enumerate(species_list):
                genome_size = num_genes_list[species_idx]
                for gene_pos in gene_set:
                    
                    start_range = gene_pos - window_size
                    end_range = gene_pos + window_size

                    synteny_range = list(range(start_range, end_range))

                    synteny_range = [genome_size + x if x < 1 else x - genome_size if x > genome_size else x for x in synteny_range]

                    # remove current element
                    current_id = synteny_range.pop(window_size)

                    synteny_lists[species_idx][current_id] = synteny_range

            # TODO make this so it generalises across multiple genomes, not only 2
            synteny_list_species1 = synteny_lists[0]
            synteny_list_species2 = synteny_lists[1]

            counter = 1
            matched_COG = set()
            for COG_id1, synteny_list1 in synteny_list_species1.items():
                
                species1_COGs = []
                for x in synteny_list1:
                    if x in position_list[0]:
                        species1_COGs.append(position_list[0][x])

                species1_COGs = set(species1_COGs)
                COG_name1 = species_names[0] + "_" + str(COG_id1).zfill(5)

                for COG_id2, synteny_list2 in synteny_list_species2.items():
                    COG_name2 = species_names[1] + "_" + str(COG_id2).zfill(5)

                    if COG_name1 in matched_COG:
                        break

                    if COG_name2 in matched_COG:
                        continue
                    
                    species2_COGs = []
                    for x in synteny_list2:
                        if x in position_list[0]:
                            species2_COGs.append(position_list[0][x])

                    species2_COGs = set(species2_COGs)

                    intersection = len(species1_COGs.intersection(species2_COGs)) / (2.0 * window_size)
                    jaccard_index = jaccard_similarity(species1_COGs, species2_COGs)

                    if debug:
                        if COG_name1 == search_COG1 and COG_name2 == search_COG2:
                            print(f"species1_COGs: {species1_COGs}")
                            print(f"species2_COGs: {species2_COGs}")
                            print(f"intersection: {intersection}")
                            print(f"jaccard_index: {jaccard_index}")

                    if jaccard_index >= min_jacc:
                        o.write(COG_name + "_" + str(counter) + "\t" + COG_name1 + "\t" + COG_name2 + "\n")
                        num_matches += 1

                        if debug:
                            if COG_id1 != COG_id2:
                                print(f"Error: genome 1 {COG_id1} != genome 2 {COG_id2}")

                        matched_COG.add(COG_name1)
                        matched_COG.add(COG_name2)
                        counter += 1
                
            for COG_id1, synteny_list in synteny_list_species1.items():
                COG_id = species_names[0] + "_" + str(COG_id1).zfill(5)

                if COG_id not in matched_COG:
                    o.write(COG_name + "_" + str(counter) + "\t" + COG_id + "\t" + "NA" + "\n")
                    counter += 1
            
            for COG_id2, synteny_list in synteny_list_species2.items():
                COG_id = species_names[1] + "_" + str(COG_id2).zfill(5)

                if COG_id not in matched_COG:
                    o.write(COG_name + "_" + str(counter) + "\t" + "NA" + "\t" + COG_id + "\n")
                    counter += 1

    print(f"Total matches: {num_matches}")

if __name__ == "__main__":
    main()