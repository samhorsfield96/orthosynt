
import argparse
from collections import defaultdict
import re

def get_options():
    description = "Splits clusters based on synteny."
    parser = argparse.ArgumentParser(description=description,
                                        prog='python orthosynt.py')
    IO = parser.add_argument_group('Input/options.out')
    IO.add_argument('--infile',
                    required=True,
                    help='tsv file generated by orthofinder')
    IO.add_argument('--outfile',
                    required=False,
                    default="parsed_output.tsv",
                    help='Output file.')
    IO.add_argument('--window-size',
                    type=int,
                    default=4,
                    help='Size either side of a gene of interest to search. Default=4')
    IO.add_argument('--min-jacc',
                    type=float,
                    default=0.5,
                    help='Minimum Jaccard index of matches to keep cluster. Default=0.5')
    IO.add_argument('--debug',
                    action="store_true",
                    default=False,
                    help='Debug mode. Only run if comparing self-self.')
    return parser.parse_args()

# for debugging
search_COG1 = ""
search_COG2 = ""

def jaccard_similarity(set1, set2):
    intersection = len(set1.intersection(set2))
    union = (len(set1) + len(set2)) - intersection
    return float(intersection) / union

def main():
    options = get_options()
    infile = options.infile
    window_size = options.window_size
    min_jacc = options.min_jacc
    outfile = options.outfile
    debug = options.debug

    COG_dict = {}
    position_list = None
    species_names = None
    num_genes_list = []
    with open(infile, "r") as f:
        header = f.readline().rstrip().split("\t")
        position_list = [ {} for _ in range(len(header) - 1)]
        num_genes_list = [ 0 for _ in range(len(header) - 1)]

        species_names = header[1:]

        for line in f:
            split_line = line.rstrip().split("\t")
            COG_name = split_line[0]
            species_entries = split_line[1:]
    
            for index, entry in enumerate(species_entries):
                species_genes = entry.split(", ")

                if species_genes == ['']:
                    continue

                species_gene_position = []
                for x in species_genes:
                    hit = re.search(r"^.+_0*(\d+)", x)
                    if hit:
                        species_gene_position.append(int(hit.group(1)))
                
                max_gene_pos = max(species_gene_position)
                prev_max_gene_pos = num_genes_list[index]
                num_genes_list[index] = max(max_gene_pos, prev_max_gene_pos)

                #species_gene_position = [int(x.split("_")[-1].lstrip("0")) for x in species_genes]
                #print(species_gene_position)

                if COG_name not in COG_dict:
                    COG_dict[COG_name] = [ set() for _ in range(len(header) - 1)]

                COG_dict[COG_name][index].update(species_gene_position)

                for pos in species_gene_position:
                    position_list[index][pos] = COG_name

    #print(f"COG_dict:\n{COG_dict}")
    #print(f"position_list:\n{position_list}")

    genes_to_ignore = set()
    COGs_to_cluster = {}
    num_matches = 0
    with open(outfile, "w") as o:
        o.write("Orthogroup\t" + "\t".join(species_names) + "\n")

        COG_name_max_id = defaultdict(int)
        for COG_name, species_list in COG_dict.items():
            synteny_lists = [ {} for _ in range(len(header) - 1)]
            for species_idx, gene_set in enumerate(species_list):
                genome_size = num_genes_list[species_idx]
                for gene_pos in gene_set:
                    
                    start_range = gene_pos - window_size
                    end_range = gene_pos + window_size

                    synteny_range = list(range(start_range, end_range))

                    synteny_range = [genome_size + x if x < 1 else x - genome_size if x > genome_size else x for x in synteny_range]

                    # remove current element
                    current_id = synteny_range.pop(window_size)

                    synteny_lists[species_idx][current_id] = synteny_range

            # --- Multi-genome generalization starts here ---
            matched_COG = set()
            
            match_dict = defaultdict(lambda: ["NA" for _ in range(len(header) - 1)])

            # Compare all pairwise genome combinations
            for i in range(len(synteny_lists)):
                for j in range(i + 1, len(synteny_lists)):

                    species_i_name = species_names[i]
                    species_j_name = species_names[j]
                    synteny_i = synteny_lists[i]
                    synteny_j = synteny_lists[j]

                    for cluster_id, (COG_id_i, synteny_list_i) in enumerate(synteny_i.items()):
                        species_i_COGs = {
                            position_list[i][x]
                            for x in synteny_list_i
                            if x in position_list[i]
                        }
                        COG_name_i = f"{species_i_name}_{str(COG_id_i).zfill(5)}"

                        for COG_id_j, synteny_list_j in synteny_j.items():
                            COG_name_j = f"{species_j_name}_{str(COG_id_j).zfill(5)}"

                            # loop logic, break if upper loop, continue if lower loop
                            # if COG_name_i in matched_COG:
                            #     continue

                            # if already placed, skip to next inner loop
                            if COG_name_j in matched_COG:
                                continue

                            species_j_COGs = {
                                position_list[j][x]
                                for x in synteny_list_j
                                if x in position_list[j]
                            }

                            #intersection = len(species_i_COGs.intersection(species_j_COGs)) / (2.0 * window_size)
                            jaccard_index = jaccard_similarity(species_i_COGs, species_j_COGs)

                            if debug and (
                                (COG_name_i == search_COG1 and COG_name_j == search_COG2)
                                or (COG_name_i == search_COG2 and COG_name_j == search_COG1)
                            ):
                                print(f"{species_i_name}_COGs: {species_i_COGs}")
                                print(f"{species_j_name}_COGs: {species_j_COGs}")
                                print(f"intersection: {intersection}")
                                print(f"jaccard_index: {jaccard_index}")

                            if jaccard_index >= min_jacc:
                                #o.write(f"{COG_name}_{counter}\t{COG_name_i}\t{COG_name_j}\n")
                                match_dict[f"{COG_name}_{cluster_id}"][i] = COG_name_i
                                match_dict[f"{COG_name}_{cluster_id}"][j] = COG_name_j

                                if COG_name_max_id[COG_name] < cluster_id:
                                    COG_name_max_id[COG_name] = cluster_id

                                matched_COG.add(COG_name_i)
                                matched_COG.add(COG_name_j)

                                if debug: 
                                    if COG_id_i != COG_id_j: 
                                        print(f"Error: genome 1 {COG_id_i} != genome 2 {COG_id_j}")

                                num_matches += 1

                                # break inner loop, found paralog
                                break

            # print matches
            for COG_id, COG_list in match_dict.items():
                o.write(f"{COG_id}\t" + "\t".join(COG_list) + "\n")

            # Handle unmatched COGs for all genomes
            for species_idx, synteny_dict in enumerate(synteny_lists):
                for COG_id, _ in synteny_dict.items():
                    COG_name_full = f"{species_names[species_idx]}_{str(COG_id).zfill(5)}"
                    if COG_name_full not in matched_COG:
                        cluster_id = COG_name_max_id[COG_name]
                        match_list = [ "NA" for _ in range(len(header) - 1)]
                        match_list[species_idx] = COG_name_full
                        o.write(f"{COG_name}_{cluster_id}\t" + "\t".join(match_list) + "\n")
                        COG_name_max_id[COG_name] += 1

    print(f"Total matches: {num_matches}")

if __name__ == "__main__":
    main()